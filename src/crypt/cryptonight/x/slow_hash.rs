/*
 * This file is part of Monume's library libmonero
 *
 * Copyright (c) 2023-2024, Monume (monume.xyz)
 * All Rights Reserved
 * The code is distributed under MIT license, see LICENSE file for details.
 * Generated by Monume
 *
 */

//! # CryptoNight Hash
//! 
//! This module contains the Rust implementation of the CryptoNight hash function, cn_slow_hash.

#[forbid(unsafe_code)] // That's the whole point of this file!

use blake2::{Blake2s256, Digest};
use groestl::Groestl256;
use jh::Jh256;
use skein::{Skein256, consts::U32};

use crate::utility::{aesu::{expand_key, aes_round}, keccaku::{keccak, keccak_f}, otheru::{to_scratchpad_address, eight_byte_add, eight_byte_xor, eight_byte_mul}};

const SCRATCHPAD_SIZE: usize = 2 * 1024 * 1024;  // 2 MiB
const AES_BLOCK_SIZE: usize = 16;

/// cn_slow_hash function used in Monero in pure Rust, defined in Cryptonote.
pub fn cn_slow_hash(input: &[u8], variant: u8, prehashed: u8, height: u64) -> [u8; 32] {
    // CryptoNight Step 1: Initialization of scratchpad
    
    // First, the input is hashed using Keccak [KECCAK] with parameters b =
    // 1600 and c = 512. The bytes 0..31 of the Keccak final state are
    // interpreted as an AES-256 key [AES] and expanded to 10 round keys. A
    // scratchpad of 2097152 bytes (2 MiB) is allocated. The bytes 64..191
    // are extracted from the Keccak final state and split into 8 blocks of
    // 16 bytes each. Each block is encrypted using the following procedure:

    //       for i = 0..9 do:
    //           block = aes_round(block, round_keys[i])

    // Where aes_round function performs a round of AES encryption, which
    // means that SubBytes, ShiftRows and MixColumns steps are performed on
    // the block, and the result is XORed with the round key. Note that
    // unlike in the AES encryption algorithm, the first and the last rounds
    // are not special. The resulting blocks are written into the first 128
    // bytes of the scratchpad. Then, these blocks are encrypted again in
    // the same way, and the result is written into the second 128 bytes of
    // the scratchpad. Each time 128 bytes are written, they represent the
    // result of the encryption of the previously written 128 bytes. The
    // process is repeated until the scratchpad is fully initialized.
    
    // Step 1A: Keccak hash and key expansion
    let keccak_output = keccak(&input[..32]);
    let expanded_key = expand_key(&keccak_output[..32]);

    // Step 1B: Initialize scratchpad with encrypted blocks
    let mut scratchpad = vec![0; SCRATCHPAD_SIZE];
    let mut block = [0; AES_BLOCK_SIZE];

    for i in 0..8 {
        // Extract 16-byte block from Keccak output
        block.copy_from_slice(&keccak_output[64 + i * AES_BLOCK_SIZE..64 + (i + 1) * AES_BLOCK_SIZE]);

        // Encrypt the block with AES for 10 rounds
        for _ in 0..10 {
            aes_round(&mut block, &expanded_key);
        }

        // Write the encrypted block to scratchpad
        scratchpad[i * AES_BLOCK_SIZE..(i + 1) * AES_BLOCK_SIZE].copy_from_slice(&block);
    }

    // Continue the process until the scratchpad is fully initialized
    for i in 8..(SCRATCHPAD_SIZE / AES_BLOCK_SIZE) {
        // XOR with previously written block
        for j in 0..AES_BLOCK_SIZE {
            block[j] ^= scratchpad[(i - 8) * AES_BLOCK_SIZE + j];
        }

        // Encrypt the block with AES for 10 rounds
        for _ in 0..10 {
            aes_round(&mut block, &expanded_key);
        }

        // Write the encrypted block to scratchpad
        scratchpad[i * AES_BLOCK_SIZE..(i + 1) * AES_BLOCK_SIZE].copy_from_slice(&block);
    }

    // CryptoNight Step 1 completed. Scratchpad is now initialized

    // CryptoNight Step 2: Memory-hard loop
    
    // Prior to the main loop, bytes 0..31 and 32..63 of the Keccak state
    // are XORed, and the resulting 32 bytes are used to initialize
    // variables a and b, 16 bytes each. These variables are used in the
    // main loop. The main loop is iterated 524,288 times. When a 16-byte
    // value needs to be converted into an address in the scratchpad, it is
    // interpreted as a little-endian integer, and the 21 low-order bits are
    // used as a byte index. However, the 4 low-order bits of the index are
    // cleared to ensure the 16-byte alignment. The data is read from and
    // written to the scratchpad in 16-byte blocks. Each iteration can be
    // expressed with the following pseudo-code:

    //       scratchpad_address = to_scratchpad_address(a)
    //       scratchpad[scratchpad_address] = aes_round(scratchpad 
    //         [scratchpad_address], a)
    //       b, scratchpad[scratchpad_address] = scratchpad[scratchpad_address],
    //         b xor scratchpad[scratchpad_address]
    //       scratchpad_address = to_scratchpad_address(b)
    //       a = 8byte_add(a, 8byte_mul(b, scratchpad[scratchpad_address]))
    //       a, scratchpad[scratchpad_address] = a xor 
    //         scratchpad[scratchpad_address], a

    // Where, the 8byte_add function represents each of the arguments as a
    // pair of 64-bit little-endian values and adds them together,
    // component-wise, modulo 2^64. The result is converted back into 16
    // bytes.

    // The 8byte_mul function, however, uses only the first 8 bytes of each
    // argument, which are interpreted as unsigned 64-bit little-endian
    // integers and multiplied together. The result is converted into 16
    // bytes, and finally the two 8-byte halves of the result are swapped.

    let mut a = [0; 16];
    let mut b = [0; 16];

    // XOR bytes 0..31 and 32..63 of the Keccak state
    for i in 0..16 {
        a[i] = keccak_output[i] ^ keccak_output[i + 32];
        b[i] = 0;
    }

    for _ in 0..524288 {
        let scratchpad_address_a = to_scratchpad_address(a);

        // Perform AES round on the scratchpad at address a
        let mut block_a = [0; AES_BLOCK_SIZE];
        block_a.copy_from_slice(&scratchpad[scratchpad_address_a..scratchpad_address_a + AES_BLOCK_SIZE]);
        aes_round(&mut block_a, &a);
        scratchpad[scratchpad_address_a..scratchpad_address_a + AES_BLOCK_SIZE].copy_from_slice(&block_a);

        // Update b and the scratchpad
        b = eight_byte_add(b, eight_byte_xor(b, block_a));
        let scratchpad_address_b = to_scratchpad_address(b);
        let mut block_b = [0; AES_BLOCK_SIZE];
        block_b.copy_from_slice(&scratchpad[scratchpad_address_b..scratchpad_address_b + AES_BLOCK_SIZE]);

        // Calculate new 'a' using eight_byte_add and eight_byte_mul
        a = eight_byte_add(a, eight_byte_mul(b, block_b));
        a = eight_byte_xor(a, block_b);
        scratchpad[scratchpad_address_b..scratchpad_address_b + AES_BLOCK_SIZE].copy_from_slice(&a);
    }
    
    // CryptoNight Step 2 completed. Memory-hard loop is now finished

    // Step 3: Keccak state expansion, encryption, and final hash selection
    let mut keccak_state = keccak(&input[32..64]);

    // Expand bytes 64..191 into 10 AES round keys
    let expanded_keys = expand_key(&keccak_state[32..64]);

    // XOR bytes 64..191 with the first 128 bytes of the scratchpad
    for i in 0..128 {
        keccak_state[i + 64] ^= scratchpad[i];
    }

    // Encrypt the result using the new keys and update the scratchpad
    for i in (0..SCRATCHPAD_SIZE).step_by(AES_BLOCK_SIZE) {
        let mut block = [0; AES_BLOCK_SIZE];
        block.copy_from_slice(&keccak_state[i % 192..i % 192 + AES_BLOCK_SIZE]);
        aes_round(&mut block, &expanded_keys);

        // XOR with the scratchpad
        for j in 0..AES_BLOCK_SIZE {
            block[j] ^= scratchpad[i + j];
        }

        // Update the scratchpad
        scratchpad[i..i + AES_BLOCK_SIZE].copy_from_slice(&block);
    }

    // Turn keccak_state into 200 byte array
    let mut keccak_state = keccak_state.as_slice().try_into().expect("Invalid length of the hash");

    // Keccak permutation
    keccak_f(&mut keccak_state);

    // Select hash function based on the 2 low-order bits of the first byte
    let hash_function_index = keccak_state[0] & 0b11;

    // Apply the selected hash function to the Keccak state
    let final_hash: [u8; 32] = match hash_function_index {
        0 => blake256(&keccak_state),
        1 => groestl256(&keccak_state),
        2 => jh256(&keccak_state),
        3 => skein256(&keccak_state),
        _ => unreachable!(), // This should never happen
    };

    // CryptoNight Step 3 completed. Keccak state expansion, encryption, and final hash selection is now finished.

    return final_hash;
}

fn blake256(data: &[u8]) -> [u8; 32] {
    // Via blake2 crate
    let mut hasher = Blake2s256::new();
    hasher.update(data);
    hasher.finalize().as_slice().try_into().expect("Invalid length of the hash")
}

fn groestl256(data: &[u8]) -> [u8; 32] {
    // Via groestl-hash crate
    let mut hasher = Groestl256::new();
    hasher.update(data);
    hasher.finalize().as_slice().try_into().expect("Invalid length of the hash")
}

fn jh256(data: &[u8]) -> [u8; 32] {
    // Via jh crate
    let mut hasher = Jh256::new();
    hasher.update(data);
    hasher.finalize().as_slice().try_into().expect("Invalid length of the hash")
}

fn skein256(data: &[u8]) -> [u8; 32] {
    // Via skein crate
    let mut hasher = Skein256::<U32>::new();
    hasher.update(data);
    hasher.finalize().as_slice().try_into().expect("Invalid length of the hash")
}